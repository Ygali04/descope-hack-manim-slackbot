const { App } = require('@slack/bolt');
const axios = require('axios');
const jwt = require('jsonwebtoken');
const { issueDelegatedJwtFromDescope } = require('./utils/descope');
const { uploadFileToSlack } = require('./utils/slack-upload');
const { validateTopic, getSuggestedTopics } = require('./utils/validation');
const { generateSafeFilename, estimateFileSize } = require('./utils/slack-upload');
const express = require('express');

require('dotenv').config();

// Direct video upload approach - no need for download function

console.log('üöÄ Starting ManimPro Slack Agent...');

const app = new App({
  token: process.env.SLACK_BOT_TOKEN,
  signingSecret: process.env.SLACK_SIGNING_SECRET,
  socketMode: true,
  appToken: process.env.SLACK_APP_TOKEN,
  port: process.env.PORT || 3000
});

// Utility functions

// Debug: Log all incoming events
app.event(/.*/, async ({ event, client }) => {
  console.log('üì® Received event:', event.type, JSON.stringify(event, null, 2));
});

// Debug: Log all incoming messages
app.message(/.*/, async ({ message, say }) => {
  console.log('üí¨ Received message:', JSON.stringify(message, null, 2));
  
  // Simple test response to ANY message
  if (message.text && message.text.toLowerCase().includes('test')) {
    await say('ü§ñ I can hear you! Bot is working!');
  }
});

// Handle mentions and direct messages for video requests
app.message(/make a (manim )?video on (.*)/i, async ({ client, message, context, say }) => {
  try {
    console.log('üé¨ Video request detected!', context.matches);

    const topic = context.matches[2].trim();
    const userId = message.user;
    const channelId = message.channel;

    // üéØ IMMEDIATE RESPONSE - Let user know we got the request!
    await say(`üé¨ Got it! Creating educational video on "${topic}"... This will take about 30-60 seconds. ‚è±Ô∏è`);

    // Validate topic
    if (!validateTopic(topic)) {
      await say(`‚ùå Sorry, I can't create a video on "${topic}". ${getSuggestedTopics()}`);
      return;
    }

    console.log(`üìù Processing video request for topic: "${topic}"`);
    console.log(`üë§ User: ${userId}, Channel: ${channelId}`);

    // Get Slack upload URL
    const filename = generateSafeFilename(topic);
    console.log(`üìÅ Generated filename: ${filename}`);

    const renderParams = {
      quality: "medium_quality",
      width: 1280,
      height: 720,
      duration_s: 30,
      fps: 30
    };

    // Get delegated JWT from Descope
    console.log('üîê Requesting delegated JWT from Descope...');
    const jwt = await issueDelegatedJwtFromDescope({
      audience: 'manimpro-agent-b',
      scope: 'video.create manim.render',
      subject: `slack-agent-${userId}`,
      actingFor: {
        slack_user_id: userId
      },
      ttl: 600 // 10 minutes
    });
    console.log('‚úÖ Got delegated JWT');

    // Call Agent B to generate video and return bytes directly
    console.log('ü§ñ Calling Agent B for video generation...');
    console.log('üîó Agent B URL:', process.env.AGENT_B_URL);
    
    const agentBRequest = {
      topic: topic,
      render: renderParams
    };

    console.log('üì° Sending request to Agent B:', JSON.stringify(agentBRequest, null, 2));

    const response = await axios.post(
      `${process.env.AGENT_B_URL}/tools/generate_and_render`,
      agentBRequest,
      {
        headers: {
          'Authorization': `Bearer ${jwt}`,
          'Content-Type': 'application/json'
        },
        timeout: 120000 // 2 minutes
      }
    );

    console.log('‚úÖ Agent B response received, video size:', response.data.video_size);

    // Get video bytes from base64 response  
    let videoBytes;
    if (response.data.video_base64) {
      videoBytes = Buffer.from(response.data.video_base64, 'base64');
      console.log('üì¶ Decoded video bytes:', videoBytes.length, 'bytes');
    } else {
      throw new Error('No video data received from Agent B');
    }
    
    const videoFilename = `manim_${topic.replace(/[^a-zA-Z0-9]/g, '_')}_${Date.now()}.mp4`;
    console.log('üì§ Uploading MP4 file directly to Slack...');
    
    const directUploadResult = await client.files.uploadV2({
      filename: videoFilename,
      file: videoBytes,
      title: `Educational Video: ${topic}`,
      initial_comment: `üéì Here's your educational video on **${topic}**!\n\nüìä *Video Details:*\n‚Ä¢ Duration: 30 seconds\n‚Ä¢ Resolution: 1280x720\n‚Ä¢ Quality: Medium\n\nüí° *Generated by ManimPro using mathematical animation*`,
      channels: channelId,
      thread_ts: message.ts
    });

    console.log('üì® Video uploaded directly to Slack channel:', directUploadResult);

  } catch (error) {
    console.error('‚ùå Error processing video request:', error);
    
    // Send user-friendly error message
    let errorMessage = '‚ùå Sorry, something went wrong creating your video. ';
    
    if (error.response) {
      console.error('üìÑ Error response data:', error.response.data);
      console.error('üìä Error response status:', error.response.status);
      
      if (error.response.status === 500) {
        errorMessage += 'The video rendering service is having issues. Please try again in a few minutes.';
      } else if (error.response.status === 401) {
        errorMessage += 'Authentication failed. Please contact support.';
      } else {
        errorMessage += `Server returned error ${error.response.status}.`;
      }
    } else if (error.code === 'ECONNREFUSED') {
      errorMessage += 'Cannot connect to the video rendering service. Please try again later.';
      console.error('üîó Connection refused - Agent B may be down');
    } else if (error.code === 'ETIMEDOUT') {
      errorMessage += 'Video generation timed out. Please try a simpler topic or try again later.';
    } else {
      errorMessage += 'Please try again or contact support if the problem persists.';
    }

    await say(errorMessage);
  }
});

// Handle slash command (optional alternative interface)
app.command('/manimpro', async ({ command, ack, respond, client }) => {
  await ack();
  
  console.log('üîß Slash command received:', command);
  
  const topic = command.text.trim();
  if (!topic) {
    await respond({
      response_type: 'ephemeral',
      text: 'Usage: `/manimpro <topic>` - e.g., `/manimpro simple harmonic motion`'
    });
    return;
  }

  // Trigger the same flow as the message handler
  const fakeMessage = {
    user: command.user_id,
    channel: command.channel_id,
    ts: command.ts || Date.now()
  };
  
  const fakeContext = {
    matches: ['', '', topic]
  };

  // Call the message handler logic
  app.message(/make a (manim )?video on (.*)/i).handlers[0]({
    client,
    message: fakeMessage,
    context: fakeContext,
    say: async (msg) => {
      await respond({
        response_type: 'in_channel',
        ...msg
      });
    }
  });
});

// Health check endpoint
app.event('app_mention', async ({ event, say }) => {
  console.log('üëã App mention received:', event);
  
  if (event.text.includes('health') || event.text.includes('status')) {
    await say({
      text: '‚úÖ ManimPro is running! Ask me to "make a video on [topic]" to create educational animations.',
      thread_ts: event.ts
    });
  }
});

// Add HTTP health endpoint for Docker health checks
const httpApp = express();

httpApp.get('/health', (req, res) => {
  res.json({ 
    status: 'healthy', 
    service: 'manimpro-slack-agent',
    timestamp: new Date().toISOString()
  });
});

// Start HTTP server for health checks
const HTTP_PORT = 3001;
httpApp.listen(HTTP_PORT, () => {
  console.log(`HTTP health server running on port ${HTTP_PORT}`);
});

// Error handlers
app.error((error) => {
  console.error('Slack app error:', error);
});

process.on('unhandledRejection', (reason, promise) => {
  console.error('Unhandled Rejection at:', promise, 'reason:', reason);
});

// Start the app
(async () => {
  await app.start();
  console.log('‚ö°Ô∏è ManimPro Slack Agent is running!');
  console.log(`Environment: ${process.env.NODE_ENV}`);
  console.log(`Agent B URL: ${process.env.AGENT_B_URL}`);
})(); 